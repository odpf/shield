package domain

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"net"
)

type Service struct {
	repository Repository
}

const (
	DNSChallenge = "_frontier-challenge.%s"
	txtLength    = 16
)

func NewService(repository Repository) *Service {
	return &Service{
		repository: repository,
	}
}

// Get an organization's whitelisted domain from the database
func (s Service) Get(ctx context.Context, id string) (Domain, error) {
	return s.repository.Get(ctx, id)
}

// List all whitelisted domains for an organization (filter by verified boolean)
func (s Service) List(ctx context.Context, flt Filter) ([]Domain, error) {
	return s.repository.List(ctx, flt)
}

// Remove an organization's whitelisted domain from the database
func (s Service) Delete(ctx context.Context, id string) (string, error) {
	return s.repository.Delete(ctx, id)
}

// Creates a record for the domain in the database and returns the TXT record that needs to be added to the DNS for the domain verification
func (s Service) Create(ctx context.Context, domain Domain) (string, error) {
	txtRecord, err := generateRandomTXT()
	if err != nil {
		return "", err
	}

	domain.Token = fmt.Sprintf(DNSChallenge, txtRecord)
	if err := s.repository.Create(ctx, domain); err != nil {
		return "", err
	}

	return domain.Token, nil
}

// VerifyDomain checks if the TXT record for the domain matches the token generated by Frontier for the domain verification
func (s Service) VerifyDomain(ctx context.Context, id string) error {
	domain, err := s.repository.Get(ctx, id)
	if err != nil {
		return ErrNotExist
	}

	txtRecords, err := net.LookupTXT(domain.Name)
	if err != nil {
		return err
	}

	for _, txtRecord := range txtRecords {
		if txtRecord == domain.Token {
			domain.Verified = true
			s.repository.Update(ctx, id, domain)
		}
	}

	return ErrNotExist
}

func generateRandomTXT() (string, error) {
	randomBytes := make([]byte, txtLength)
	_, err := rand.Read(randomBytes)
	if err != nil {
		return "", err
	}

	// Encode the random bytes in Base64
	txtRecord := base64.StdEncoding.EncodeToString(randomBytes)
	return txtRecord, nil
}
