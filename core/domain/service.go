package domain

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"net"
	"strings"

	"github.com/raystack/frontier/core/authenticate"
	"github.com/raystack/frontier/core/organization"
	"github.com/raystack/frontier/core/user"
	"github.com/raystack/frontier/internal/bootstrap/schema"
)

type UserService interface {
	GetByID(ctx context.Context, id string) (user.User, error)
}

type OrgService interface {
	ListByUser(ctx context.Context, userID string) ([]organization.Organization, error)
	AddMember(ctx context.Context, orgID, relationName string, principal authenticate.Principal) error
}

type Service struct {
	repository  Repository
	userService UserService
	orgService  OrgService
}

const (
	DNSChallenge = "_frontier-challenge.%s"
	txtLength    = 16
)

func NewService(repository Repository, userService UserService, orgService OrgService) *Service {
	return &Service{
		repository:  repository,
		userService: userService,
		orgService:  orgService,
	}
}

// Get an organization's whitelisted domain from the database
func (s Service) Get(ctx context.Context, id string) (Domain, error) {
	return s.repository.Get(ctx, id)
}

// List all whitelisted domains for an organization (filter by verified boolean)
func (s Service) List(ctx context.Context, flt Filter) ([]Domain, error) {
	return s.repository.List(ctx, flt)
}

// Remove an organization's whitelisted domain from the database
func (s Service) Delete(ctx context.Context, id string) error {
	return s.repository.Delete(ctx, id)
}

// Creates a record for the domain in the database and returns the TXT record that needs to be added to the DNS for the domain verification
func (s Service) Create(ctx context.Context, domain Domain) (string, error) {
	txtRecord, err := generateRandomTXT()
	if err != nil {
		return "", err
	}

	domain.Token = fmt.Sprintf(DNSChallenge, txtRecord)
	if err := s.repository.Create(ctx, domain); err != nil {
		return "", err
	}

	return domain.Token, nil
}

// VerifyDomain checks if the TXT record for the domain matches the token generated by Frontier for the domain verification
func (s Service) VerifyDomain(ctx context.Context, id string) error {
	domain, err := s.repository.Get(ctx, id)
	if err != nil {
		return ErrNotExist
	}

	txtRecords, err := net.LookupTXT(domain.Name)
	if err != nil {
		return err
	}

	for _, txtRecord := range txtRecords {
		if txtRecord == domain.Token {
			domain.Verified = true
			s.repository.Update(ctx, domain)
		}
	}

	return ErrNotExist
}

// Join an organization as a member if the user domain matches the org whitelisted domains
func (s Service) Join(ctx context.Context, orgID string, userId string) error {
	currUser, err := s.userService.GetByID(ctx, userId)
	if err != nil {
		return err
	}

	// check if user is already a member of the organization. if yes, do nothing and return nil
	userOrgs, err := s.orgService.ListByUser(ctx, currUser.ID)
	if err != nil {
		return err
	}

	for _, org := range userOrgs {
		if org.ID == orgID {
			return nil
		}
	}

	userDomain := extractDomainFromEmail(currUser.Email)
	if userDomain == "" {
		return user.ErrInvalidEmail
	}

	// check if user domain matches the org whitelisted domains
	orgTrustedDomains, err := s.List(ctx, Filter{
		OrgID:    orgID,
		Verified: true,
	})
	if err != nil {
		return err
	}

	for _, dmn := range orgTrustedDomains {
		if userDomain == dmn.Name {
			if err = s.orgService.AddMember(ctx, orgID, schema.MemberRelationName, authenticate.Principal{
				ID:   currUser.ID,
				Type: schema.UserPrincipal,
			}); err != nil {
				return err
			}
			return nil
		}
	}

	return ErrDomainsMisMatch
}

func generateRandomTXT() (string, error) {
	randomBytes := make([]byte, txtLength)
	_, err := rand.Read(randomBytes)
	if err != nil {
		return "", err
	}

	// Encode the random bytes in Base64
	txtRecord := base64.StdEncoding.EncodeToString(randomBytes)
	return txtRecord, nil
}

func extractDomainFromEmail(email string) string {
	parts := strings.Split(email, "@")
	if len(parts) == 2 {
		return parts[1]
	}
	return ""
}
